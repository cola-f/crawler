<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>자동매매 백테스트</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
		<!-- Chart.js용 Luxon 날짜 어댑터 -->
	<script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

</head>
<body>
	<h2>INV</h2>
		<label>Start: <input id="start" type="datetime-local" value="2024-05-30T00:00"></label>
	<label>End: <input id="end" type="datetime-local" value="2024-06-01T00:00" /></label><br><br>

	<label for="portfolioInput">포트폴리오 JSON 입력:</label><br>
	<input type="text" id="portfolioInput" style="width: 400px;" value='{"BTC": 0.4, "ETH": 0.4, "XRP": 0.1}'>
	<button onclick="setPortfolio()">전송</button><br>

	<button onclick="plot('/load')">📂 Load</button>
	<button onclick="plot('/getOhlcv')">📈 Get OHLCV</button>
	<input type="number" id = "intInput" step = "1" value = "10000000">
	<button onclick = "backtest('/backtest')">📊 Backtest</button>
	<button onclick="send('/save')">save</button>
	<button onclick="send('/accounts')">accounts</button>
	<button onclick="send('/execute')">execute</button>
	<button onclick="send('/stop')">stop</button>

	<canvas id = "record" width = 100% height = 50%></canvas>
	<ul id="messages"></ul>

	<script>
		async function fetchMessages(){
				const res = await fetch("/messages");
				const messages = await res.json();
				const container = document.getElementById("messages");
				messages.forEach(msg => {
					const li = document.createElement("li");
					li.textContent = `${msg.message}`;
					container.insertBefore(li, container.firstChild);
				});
		}
		async function setPortfolio(){
			const input = document.getElementById("portfolioInput").value;
			let portfolio;
			try{
				portfolio = JSON.parse(input);
			}
			catch(e){
				alert("유효한JSON형식이 아닙니다.");
				return;
			}
			const res = await fetch("/setPortfolio", {
				method: "POST",
				headers: {
					"Content-Type": "application/json"
				},
				body: JSON.stringify({portfolio})
			});
		}
		async function send(path) {
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end });

			const res = await fetch(path, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body
			});
		}
		setInterval(fetchMessages, 3000);
		fetchMessages();
		let chart;
		async function plot(path) {
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end});
			const res = await fetch(path, {
			method: "POST",
				headers: { "Content-Type": "application/json" },
			body
			});
			const data = await res.json();
			let datasets = []
			for(let item in data){
				const priceData = data[item].map(d => ({
					x: d.candle_date_time_kst,
					y: d.normalized_value,
					price: d.trade_price,
				}));
				datasets.push({
					label: item,
					data: priceData,
					borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
					borderWidth: 2,
					pointRadius: 0,
					fill: false
			  }); 
			}
			const ctx = document.getElementById("record").getContext("2d");
			if(chart){
			  chart.destroy()
			}
			chart = new Chart(ctx, {
				type: "line",
				data: {
					datasets: datasets
				},
				options: {
					responsive: true,
					scales: {
						x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd', unit: "day" }, title: { display: true, text: 'Date' } },
						y: { title: { display: true, text: '가격' } }
					},
					tooltip: {
						callbacks:{
							label: function(context){
								const point = context.raw;
								return `${point.price}`;
							}
						},
						mode: 'index',
						intersect: false
					}
				}
			});
		};
		async function backtest(path) {
			const krw = parseInt(document.getElementById("intInput").value);
			if(isNaN(krw)){
				alert("정수를 입력하세요.");
				return;
			}
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end, krw: krw});
			const res = await fetch(path, {
			method: "POST",
				headers: { "Content-Type": "application/json" },
			body
			});
			const data = await res.json();
			console.log(data);
			let datasets = []
			for(let item in data){
				const priceData = data[item].map(d => ({
					x: d.candle_date_time_kst,
					y: d.normalized_value,
					price: d.trade_price,
					quantity: d.backtest_trade_quantity
				}));
				datasets.push({
					label: item,
					data: priceData,
					borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
					borderWidth: 2,
					pointRadius: 0,
					fill: false,
					datalabels: {
						align: "top",
						anchor: "end",
						formatter: function(value, context) {
							return value.quantity + "@" + value.price;
						},
						color: function(context){
							const qty = context.dataset.data[context.dataIndex].quantity;
            				return qty > 0 ? "red" : qty < 0 ? "blue" : "transparent";
						},
						font: {
							weight: "bold"
						}
					}
			  }); 
			}
			const ctx = document.getElementById("record").getContext("2d");
			if(chart){
			  chart.destroy()
			}
			chart = new Chart(ctx, {
				type: "line",
				data: {
					datasets: datasets
				},
				options: {
					responsive: true,
					plugins: {
						tooltips: {
							callbacks: {
								label: function(context){
									const price = context.raw.trade_price;
									return `${price.toLocaleString()}`;
								}
							}
						},
						legend: {display: true},
						datalabels: {
							display: true
						}
					},
					scales: {
						x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd', unit: "day" }, title: { display: true, text: 'Date' } },
						y: { title: { display: true, text: '가격' } }
					}
				},
				plugins: [ChartDataLabels] 
			});
		};
		async function transaction(path) {
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end});
			const res = await fetch(path, {
			method: "POST",
				headers: { "Content-Type": "application/json" },
			body
			});
			const data = await res.json();
			let datasets = []
			for(let item in data){
				labels = data[item].map(d => d.candle_date_time_kst);
				const prices = data[item].map(d => d.normalized_value);
				datasets.push({
					label: item,
					data: prices,
					borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
					borderWidth: 2,
					pointRadius: 0,
					fill: false
			  }); 
			}
			for(item in data){
				labels = data[item].map(d => d.candle_date_time_kst);
				const labelData = data[item].map(d => ({
					x: d.candle_date_time_kst,
					y: d.normalized_value,
					quantity: d.trade_quantity
				}));
				datasets.push({
					label: "Quantity" + item,
					data: labelData,
					pointRadius: 0,
					borderWidth: 0,
					datalabels: {
						aline: "top",
						anchor: "end",
						formatter: function(value, context) {
							return value.quantity !== 0 ? value.quantity.toFixed(4) : "";
						},
						color: function(context){
							const qty = context.dataset.data[context.dataIndex].quantity;
							return qty > 0 ? "blue" : qty < 0 ? "blue" : "transparent";
						},
						font: {
							weight: "bold"
						}
					}
				})
			}
			const ctx = document.getElementById("record").getContext("2d");
			if(chart){
			  chart.destroy()
			}
			chart = new Chart(ctx, {
				type: "line",
				data: {
					labels: labels,
					datasets: datasets
				},
				options: {
					responsive: true,
					scales: {
						x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd', unit: "day" }, title: { display: true, text: 'Date' } },
						y: { title: { display: true, text: '가격' } }
					},
				  plugins: [ChartDataLabels] 
				}
			});
		};


	
	</script>
</body>
</html>

