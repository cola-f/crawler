<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>4,266,966</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
    }
    #toolbar {
      height: 10%;
      width: 100%;
      padding: 5px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      background-color: #f0f0f0;
      box-sizing: border-box;
    }
    #main {
      display: flex;
      height: 90%;
    }
    #chartContainer {
      width: 70%;
      height: 100%;
      padding: 10px;
    }
    #record {
      width: 100%;
      height: 100%;
    }
    #messages {
      width: 30%;
      height: 100%;
      margin: 0;
      padding: 10px;
      list-style: none;
      overflow-y: auto;
      border-left: 1px solid #ccc;
      background-color: #fafafa;
    }
    li {
      padding: 4px 0;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <label>Start: <input id="start" type="datetime-local" value="2025-05-01T00:00"></label>
    <label>End: <input id="end" type="datetime-local" value="2025-05-05T00:00"></label>
    <input type="text" id="portfolioInput" style="width: 400px;" value='{"BTC": 0.3, "ETH": 0.3, "XRP": 0.2}'>
    <button onclick="setPortfolio()">전송</button>
    <button onclick="plot('/load')">📂 Load</button>
    <button onclick="plot('/getOhlcv')">📈 Get OHLCV</button>
    <input type="number" id="intInput" step="1" value="10000000">
    <button onclick="backtest('/backtest')">📊 Backtest</button>
    <button onclick="send('/save')">save</button>
    <button onclick="send('/accounts')">accounts</button>
    <button onclick="send('/execute')">execute</button>
    <button onclick="send('/stop')">stop</button>
  </div>

  <div id="main">
    <div id="chartContainer">
      <canvas id="record"></canvas>
    </div>
    <ul id="messages"></ul>
  </div>
	<script>
		function numberFormatter(number){
			const formatted = Number(number)?.toLocaleString('en-US', {
				maximumFractionDigits: 2
			}) ?? '';
			return formatted;
		}
		async function fetchMessages(){
			const res = await fetch("/messages");
			const messages = await res.json();
			const container = document.getElementById("messages");
			messages.forEach(msg => {
				const li = document.createElement("li");
				li.textContent = `${msg.message}`;
				container.insertBefore(li, container.firstChild);
			});
		}
		async function setPortfolio(){
			const input = document.getElementById("portfolioInput").value;
			let portfolio;
			try{
				portfolio = JSON.parse(input);
			}
			catch(e){
				alert("유효한JSON형식이 아닙니다.");
				return;
			}
			const res = await fetch("/setPortfolio", {
				method: "POST",
				headers: {
					"Content-Type": "application/json"
				},
				body: JSON.stringify({portfolio})
			});
		}
		async function send(path) {
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end });

			const res = await fetch(path, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body
			});
		}
		setInterval(fetchMessages, 3000);
		fetchMessages();
		let chart;
		async function plot(path) {
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end});
			const res = await fetch(path, {
			method: "POST",
				headers: { "Content-Type": "application/json" },
			body
			});
			const data = await res.json();
			let datasets = []
			for(let item in data){
				const priceData = data[item].map(d => ({
					x: d.candle_date_time_kst,
					y: d.normalized_value,
					price: d.trade_price,
				}));
				datasets.push({
					label: item,
					data: priceData,
					borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
					borderWidth: 2,
					pointRadius: 0,
					fill: false
			  }); 
			}
			const ctx = document.getElementById("record").getContext("2d");
			if(chart){
			  chart.destroy()
			}
			chart = new Chart(ctx, {
				type: "line",
				data: {
					datasets: datasets
				},
				options: {
					responsive: true,
					scales: {
						x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd', unit: "day" }, title: { display: true, text: 'Date' } },
						y: {
							title: {
								display: true,
								text: '가격' },
							type: 'logarithmic'
						}
					},
					plugins: {
						tooltip: {
							callbacks:{
								label: function(context){
									const point = context.raw;
									return `${point.price}`;
								}
							},
							mode: 'index',
							intersect: false
						}
					}
				}
			});
		};
		async function backtest(path) {
			const krw = parseInt(document.getElementById("intInput").value);
			if(isNaN(krw)){
				alert("정수를 입력하세요.");
				return;
			}
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end, krw: krw});
			const res = await fetch(path, {
			method: "POST",
				headers: { "Content-Type": "application/json" },
			body
			});
			const data = await res.json();
			console.log(data);
			let datasets = []
			for(let item in data){
				const priceData = data[item].map(d => ({
					x: d.candle_date_time_kst,
					y: d.normalized_value,
					price: d.trade_price,
					quantity: d.backtest_trade_quantity
				}));
				datasets.push({
					label: item,
					data: priceData,
					borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
					borderWidth: 2,
					pointRadius: 0,
					fill: false,
					datalabels: {
						align: "top",
						anchor: "end",
						formatter: function(value, context) {
							return numberFormatter(value.quantity) + "\n@" + numberFormatter(value.price);
						},
						color: function(context){
							const qty = context.dataset.data[context.dataIndex].quantity;
							return qty > 0 ? "blue" : qty < 0 ? "red" : "transparent";
						},
						font: {
							weight: "bold"
						}
					}
			  }); 
			}
			const ctx = document.getElementById("record").getContext("2d");
			if(chart){
			  chart.destroy()
			}
			chart = new Chart(ctx, {
				type: "line",
				data: {
					datasets: datasets
				},
				options: {
					responsive: true,
					plugins: {
						tooltip: {
							callbacks:{
								label: function(context){
									const point = context.raw;
									return `${numberFormatter(point.price)}`;
								}
							},
							mode: 'index',
							intersect: false
						},
						legend: {display: true},
						datalabels: {
							display: true
						}
					},
					scales: {
						x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd', unit: "day" }, title: { display: true, text: 'Date' } },
						y: {
							title: {
								display: true,
								text: '가격'
							},
							type: 'logarithmic'
						}
					}
				},
				plugins: [ChartDataLabels] 
			});
		};
		async function transaction(path) {
			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const body = JSON.stringify({ start: start, end: end});
			const res = await fetch(path, {
			method: "POST",
				headers: { "Content-Type": "application/json" },
			body
			});
			const data = await res.json();
			let datasets = []
			for(let item in data){
				labels = data[item].map(d => d.candle_date_time_kst);
				const prices = data[item].map(d => d.normalized_value);
				datasets.push({
					label: item,
					data: prices,
					borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
					borderWidth: 2,
					pointRadius: 0,
					fill: false
			  }); 
			}
			for(item in data){
				labels = data[item].map(d => d.candle_date_time_kst);
				const labelData = data[item].map(d => ({
					x: d.candle_date_time_kst,
					y: d.normalized_value,
					quantity: d.trade_quantity
				}));
				datasets.push({
					label: "Quantity" + item,
					data: labelData,
					pointRadius: 0,
					borderWidth: 0,
					datalabels: {
						aline: "top",
						anchor: "end",
						formatter: function(value, context) {
							return value.quantity !== 0 ? value.quantity.toFixed(4) : "";
						},
						color: function(context){
							const qty = context.dataset.data[context.dataIndex].quantity;
							return qty > 0 ? "blue" : qty < 0 ? "blue" : "transparent";
						},
						font: {
							weight: "bold"
						}
					}
				})
			}
			const ctx = document.getElementById("record").getContext("2d");
			if(chart){
			  chart.destroy()
			}
			chart = new Chart(ctx, {
				type: "line",
				data: {
					labels: labels,
					datasets: datasets
				},
				options: {
					responsive: true,
					scales: {
						x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd', unit: "day" }, title: { display: true, text: 'Date' } },
						y: { title: { display: true, text: '가격' } }
					},
				  plugins: [ChartDataLabels] 
				}
			});
		};
	</script>
</body></html>
